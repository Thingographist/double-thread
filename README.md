# double-thread

##  Описание

Сеть построенная на двух каналах: поток данных (stream) и состояние (transition)

1. необработанные данные хранить в специальном стеке
2. Динамическое построение сети в качественном смысле (добавление и переопределение узлов)

Плюсы от применения `core.async`

1. Избавление от рекурсивных циклов `clojure` типа `loop-recur`.
2. Вся цепь вычисления представленна списком данных.

Для регисрации узла в сети нужно, определить методы для классов параметров `[RequestClass & data-classes]`. Например 

```clojure
(defmethod thread-handler [Request String] [_ m]
  (println m))

(defmethod thread-handler [Confirm String] [_ m])

(defmethod thread-handler [Error String] [e _]
  (println "Ошибка: " e))
```

> В перспективе обернуть макросом Node-Handler

#### тип Request

Запрос на обработку данных. Содержит в себе стек классов вызывов.

#### тип Confirm

Подтверждение отправки сообщений. 
Какаая реакция должна быть в случае не обработанного сообщения?

Содердит стек вызывов.

Прдназначен для повторного пользовательского запроса данных.

Пример: переменилось глобальное состояние, от которого зависит узел, и при этом вычисление теряет смысл и пользователь хочет иницировать повторное вычисление.

#### тип Error

Содержит сообщение о ошибке. 
> Вводится для того, чтобы всю сеть не выполнять в `try/catch`

Данный тип подразумевает блокирующую ошибку в цепочке, то есть дальнейшее вычисление не имеет смысла.

## Проблемы

#### Каналы

Превышение размера очереди

#### Текущая обработка

Как оторазить исходный код заданного обработчика?

#### Неоходимость Confirm, Error

Может всю потоковую информацию складывать в метаданные?

#### pmap над списками

С одной стороны, обработчик канала один и соответсвенно все вызовы зависят от очереди в канале.
С другой стороны, как обрабатывать подтверждения статуса выполнения. Из этого вытекает следующая проблема.

Как управлять количеством потоков.

#### Управление каналом transition

Пользователь сам должен отправлять все сообщения или они должны обрабатываться автоматически?

#### объединение Confirm и Error

Должен быть один тип ответного сообщения или каждое сообщение должно быть типизированным

#### замена обработчиков в время выполнения

1. При большом объеме кода загружать возможно только через чтение потока
2. Пока еще не известно, будет ли заменен обработчик на новый для исполняемой нитки
3. какой алгоритм замены

#### Хранение необработанных данных (Collector)

1. Что делать если не найден обработчик?
2. Что делать при не обработанных исключениях?
3. Как "чистить" необработанные сообщения
4. Кто должен заниматься очисткой коллектора?

#### Дефолтные обработчики

Какая стандартная реализация у обработчиков. 
Нужна ли она для Confirm и Error или пользователь сам должен контролировать всю логику?

## Usage

in shell

```bash
lrun -m double-thread.core
```

## License

Copyright © 2015 FIXME

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
